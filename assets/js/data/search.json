[ { "title": "[ue4] UObject reference finder", "url": "/posts/uobject-reference/", "categories": "Unreal Engine, Manual", "tags": "ue4, manual", "date": "2022-02-20 00:00:00 +0900", "snippet": "UML int32 GetObjReferenceCount(UObject* Obj, TArray&amp;lt;UObject*&amp;gt;* OutReferredToObjects = nullptr){ if(!Obj || !Obj-&amp;gt;IsValidLowLevelFast()) { return -1; } TArray&amp;lt;UObject*&amp;gt; ReferredToObjects; //req outer, ignore archetype, recursive, ignore transient FReferenceFinder ObjectReferenceCollector( ReferredToObjects, Obj, false, true, true, false); ObjectReferenceCollector.FindReferences( Obj ); if(OutReferredToObjects) { OutReferredToObjects-&amp;gt;Append(ReferredToObjects); } return OutReferredToObjects.Num();}" }, { "title": "[ue4] UObject reference finder", "url": "/posts/unreal-json-manual/", "categories": "Unreal Engine, Manual", "tags": "ue4, manual", "date": "2022-02-20 00:00:00 +0900", "snippet": "UML int32 GetUObjectReferences(UObject* Object, TArray&amp;lt;UObject*&amp;gt;&amp;amp; OutReferredToObjects){ if(!Obj || !Obj-&amp;gt;IsValidLowLevelFast()) { return -1; } TArray&amp;lt;UObject*&amp;gt; ReferredToObjects; FReferenceFinder ObjectReferenceCollector( ReferredToObjects, Obj, false, true, true, false); ObjectReferenceCollector.FindReferences( Obj ); if(OutReferredToObjects) { OutReferredToObjects-&amp;gt;Append(ReferredToObjects); } return OutReferredToObjects.Num();}" }, { "title": "Template Method", "url": "/posts/template-method/", "categories": "Design Pattern, Behavior", "tags": "Design Pattern, Behavior", "date": "2022-02-20 00:00:00 +0900", "snippet": "템플릿 메소드 패턴은 우리가 흔히 사용하고 있는 패턴 중 하나이다. 추상 클래스와 추상 메소드를 준비하고, 하위 클래스는 상속을 통해 이를 구현하는 방식이다. 템플릿 메소드 패턴의 핵심은 상속을 통해 추상 메소드를 서로 다른 방식으로 구현할 수 있다는 점이다. 이 부분은 시스템을 확장해 나간다는 측면에서 OCP원칙을 준수하고 있다고 볼 수 있다.UML" }, { "title": "[ue4] Module", "url": "/posts/module/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2022-02-19 00:00:00 +0900", "snippet": "                                                                                          Public Directory &amp;amp; Private Directory엔진에서는 기본적으로 Public Directory와 Private Direcotry를 구분한다. 이는 해당 모듈의 기능을 다른 모듈에서 참조하도록 하기 위함인데, Public Directory에 넣고 MODULE_API를 달아주면 다른 모듈에서 참조가 가능하고,Private Directory에 넣으면 다른 모듈에서 참조할 수 없도록 해야한다. Private Directory에 MODULE_API 달면 접근은 가능하다. 하지만 이렇게 하지 말자.IncludePathModuleNames &amp;amp; DependencyModuleNames공통점 다른 모듈에서 Public Directory의 헤더를 포함할 수 있다.차이점 IncludePathModuleNames는 링크를 하지 않는다. 헤더 자체에 접근은 할 수 있지만 링크가 필요한 클래스나 함수 접근 시, 링크 에러(error LNK2019: unresolved external symbol)가 발생한다. IncludePathModuleNames는 과거의 사용법이다. 가급적이면 DependencyModuleNames만 사용하자.PublicDependencyModuleNames &amp;amp; PrivateDependencyModuleNames/// &amp;lt;summary&amp;gt;/// List of public dependency module names (no path needed) (automatically does the private/public include). These are modules that are required by our public source files./// &amp;lt;/summary&amp;gt;public List&amp;lt;string&amp;gt; PublicDependencyModuleNames = new List&amp;lt;string&amp;gt;();/// &amp;lt;summary&amp;gt;/// List of private dependency module names. These are modules that our private code depends on but nothing in our public/// include files depend on./// &amp;lt;/summary&amp;gt;public List&amp;lt;string&amp;gt; PrivateDependencyModuleNames = new List&amp;lt;string&amp;gt;();해당 코드 주석을 보고 내가 이해한 것은 아래와 같다. PublicDependencyModuleNames은 Public Directory를 접근이 가능하다. PrivateDependencyModuleNames는 Private Directory를 접근이 가능하다.그래서 이해한 것이 맞는지 테스트를 해보았다. A Module에 Public Directory 노출 클래스, Private Directory 노출 클래스를 추가 Main Module에서 A Module Private Dependency로 추가 Main Module에서 A Module의 Public Directory에 선언된 클래스와 Private Directory에 선언된 클래스를 각각 접근해당 테스트를 통해 Private Directory 클래스를 접근하지 못하는 것을 확인했다.결론: ModuleNames은 Directory와 관련이 없었다.모듈 접근 시나리오 A 모듈에 선언된 Private Dependency이므로 Main Module에서는 B Module을 참조할 수 없다. A 모듈에 선언된 Public Dependency인 B 모듈은 헤더의 참조는 되지만 링크 에러가 난다. 결론: PublicDependencyModuleNames은 헤더 파일의 정보만 전달, Link는 전달해주지 않는다. 모듈(e.g. MainModule)에서 명시적으로 사용하려는 모듈을 참조해주자.사용법public BModule(ReadOnlyTargetRules Target) : base(Target){}public AModule(ReadOnlyTargetRules Target) : base(Target){ PrivateDependencyModuleNames.Add(&quot;AModule&quot;);}public MainModule(ReadOnlyTargetRules Target) : base(Target){ PrivateDependencyModuleNames.Add(&quot;AModule&quot;); PrivateDependencyModuleNames.Add(&quot;BModule&quot;);} 그냥 PrivateDependencyModuleNames만 사용하자" }, { "title": "[ue4] Engine Launch", "url": "/posts/engine-launch/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2022-02-19 00:00:00 +0900", "snippet": "                                                                                          Engine Launchint32 GuardedMain( const TCHAR* CmdLine ){ EnginePreInit( CmdLine ); EngineInit(); while( !IsEngineExitRequested() ) { EngineTick(); } EngineExit();}GEngineLoop.PreInit LoadCoreModules CoreUObject LoadPreInitModules Engine Renderer AnimGraphRuntime FPlatformApplicationMisc::LoadPreInitModules(); &amp;lt;Client&amp;gt; SlateRHIRenderer Landscape RenderCore &amp;lt;Editor&amp;gt; TextureCompressor &amp;lt;Editor&amp;gt; AudioEditor &amp;lt;Editor&amp;gt; AnimationModifiers AppInit FPlatformMisc::PlatformPreInit(); LoadModules(ELoadingPhase::EarliestPossible) LoadModules(ELoadingPhase::PostConfigInit) LoadModulesForProject(ELoadingPhase::PostSplashScreen) LoadModulesForProject(ELoadingPhase::PreEarlyLoadingScreen) LoadStartupCoreModules Core Networking FPlatformApplicationMisc::LoadStartupModules(); Messaging &amp;lt;Client&amp;gt; MRMesh &amp;lt;Editor&amp;gt; UnrealEd &amp;lt;Editor&amp;gt; EditorStyle &amp;lt;Client&amp;gt; LandscapeEditorUtilities &amp;lt;Client&amp;gt; SlateCore &amp;lt;Client&amp;gt; UMG &amp;lt;Editor&amp;gt; CollisionAnalyzer &amp;lt;Editor&amp;gt; BehaviorTreeEditor &amp;lt;Editor&amp;gt; GameplayTasksEditor &amp;lt;Editor&amp;gt; AudioEditor &amp;lt;Client&amp;gt; Overlay MediaAssets ClothingSystemRuntimeNv &amp;lt;Editor&amp;gt; ClothingSystemEditor PacketHandler NetworkReplayStreaming PreInitPostStartupScreen LoadModules(ELoadingPhase::EarliestPossible) LoadModules(ELoadingPhase::PreDefault) LoadModules(ELoadingPhase::Default) LoadModules(ELoadingPhase::PostDefault) 모듈이 로드될 때, 엔진은 해당 모듈에 정의된 모든 UObject 클래스 등록FModuleDescriptor::LoadModulesForPhase Replection 시스템에 의해 클래스들을 인식 각 CDO(Class-Default-Object)를 구성 [CDO란 기본 상태의 클래스] IModuleInterface::StartupModule 호출GEngineLoop.Initint32 FEngineLoop::Init(){ GEngine = NewObject&amp;lt;UEngine&amp;gt;(GetTransientPackage(), EngineClass); GEngine-&amp;gt;ParseCommandline(); GEngine-&amp;gt;Init(this); FCoreDelegates::OnPostEngineInit.Broadcast(); IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit); IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostEngineInit); GEngine-&amp;gt;Start(); GIsRunning = true; FCoreDelegates::OnFEngineLoopInitComplete.Broadcast();}UGameEngine::Init Create GameInstance &amp;lt;Client&amp;gt; Create GameViewportClient &amp;lt;Client&amp;gt; Create LocalPlayerUGameEngine::Start GameInstance-&amp;gt;StartGameInstance UEngine::Browse UEngine::LoadMap " }, { "title": "[ue4] Gabage Collection", "url": "/posts/gabage-collection/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2022-02-18 00:00:00 +0900", "snippet": "언리얼 엔진에서는 가비지 컬렉션 방식 중 하나인 Mark and sweep 방식을 사용한다. 이 방식은 Root기반으로 참조된 노드를 순회하며 참조된 노드들은 마킹(Mark)하고, 마킹되지 않은 오브젝트들은 제거(Sweep)하는 방식이다.                                        Mark and sweepUnreal garbage collectionoverview/** * Deletes all unreferenced objects, keeping objects that have any of the passed in KeepFlags set * * @param KeepFlags objects with those flags will be kept regardless of being referenced or not * @param bPerformFullPurge if true, perform a full purge after the mark pass */void CollectGarbageInternal(EObjectFlags KeepFlags, bool bPerformFullPurge){ //@ Mark { const double StartTime = FPlatformTime::Seconds(); FRealtimeGC TagUsedRealtimeGC; TagUsedRealtimeGC.PerformReachabilityAnalysis(KeepFlags, bForceSingleThreadedGC, bWithClusters); UE_LOG(LogGarbage, Log, TEXT(&quot;%f ms for GC&quot;), (FPlatformTime::Seconds() - StartTime) * 1000); } //@ Sweep { GatherUnreachableObjects(bForceSingleThreadedGC); NotifyUnreachableObjects(GUnreachableObjects); // This needs to happen after GatherUnreachableObjects since GatherUnreachableObjects can mark more (clustered) objects as unreachable FGCArrayPool::Get().ClearWeakReferences(bPerformFullPurge); if (bPerformFullPurge || !GIncrementalBeginDestroyEnabled) { UnhashUnreachableObjects(/**bUseTimeLimit = */ false); FScopedCBDProfile::DumpProfile(); } }}FGCReferenceTokenStreamUClass에 정의된 프로퍼티들의 토큰으로 캐싱한다./** * Convenience struct containing all necessary information for a reference. */struct FGCReferenceInfo{ union { struct { /** Return depth, e.g. 1 for last entry in an array, 2 for last entry in an array of structs of arrays, ... */ uint32 ReturnCount : 8; /** Type of reference */ uint32 Type : 5; // The number of bits needs to match TFastReferenceCollector::FStackEntry::ContainerHelperType /** Offset into struct/ object */ uint32 Offset : 19; }; /** uint32 value of reference info, used for easy conversion to/ from uint32 for token array */ uint32 Value; };}; UClass::AssembleReferenceTokenStream GC를 위한 클래스 별 Token stream 런타임 상에 한번만 실행Mark processvoid PerformReachabilityAnalysis(EObjectFlags KeepFlags, bool bForceSingleThreaded, bool bWithClusters){ /** Growing array of objects that require serialization */ FGCArrayStruct* ArrayStruct = FGCArrayPool::Get().GetArrayStructFromPool(); TArray&amp;lt;UObject*&amp;gt;&amp;amp; ObjectsToSerialize = ArrayStruct-&amp;gt;ObjectsToSerialize; // Reset object count. GObjectCountDuringLastMarkPhase.Reset(); // Make sure GC referencer object is checked for references to other objects even if it resides in permanent object pool if (FPlatformProperties::RequiresCookedData() &amp;amp;&amp;amp; FGCObject::GGCObjectReferencer &amp;amp;&amp;amp; GUObjectArray.IsDisregardForGC(FGCObject::GGCObjectReferencer)) { ObjectsToSerialize.Add(FGCObject::GGCObjectReferencer); } { const double StartTime = FPlatformTime::Seconds(); (this-&amp;gt;*MarkObjectsFunctions[GetGCFunctionIndex(!bForceSingleThreaded, bWithClusters)])(ObjectsToSerialize, KeepFlags); UE_LOG(LogGarbage, Verbose, TEXT(&quot;%f ms for MarkObjectsAsUnreachable Phase (%d Objects To Serialize)&quot;), (FPlatformTime::Seconds() - StartTime) * 1000, ObjectsToSerialize.Num()); } { const double StartTime = FPlatformTime::Seconds(); PerformReachabilityAnalysisOnObjects(ArrayStruct, bForceSingleThreaded, bWithClusters); UE_LOG(LogGarbage, Verbose, TEXT(&quot;%f ms for Reachability Analysis&quot;), (FPlatformTime::Seconds() - StartTime) * 1000); }}Sweep process" }, { "title": "[ue4] UObject", "url": "/posts/uobject/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2022-02-18 00:00:00 +0900", "snippet": "UObject는 언리얼의 근간이 되는 오브젝트이다. 이 장에서는 UObject의 생성, 삭제 및 TWeakObjectPtr의 작동 방식을 알아보았다.                                        New Objecttemplate&amp;lt; class T &amp;gt;T* NewObject(UObject* Outer = (UObject*)GetTransientPackage()){ return static_cast&amp;lt;T*&amp;gt;(StaticConstructObject_Internal(Params));}UObject* StaticAllocateObject(...){ UObject* Obj = NULL; if(InName == NAME_None) { InName = MakeUniqueObjectName(InOuter, InClass); } else { // See if object already exists. Obj = StaticFindObjectFastInternal( /*Class=*/ NULL, InOuter, InName, true ); } int32 TotalSize = InClass-&amp;gt;GetPropertiesSize(); checkSlow(TotalSize); if( Obj == NULL ) { int32 Alignment = FMath::Max( 4, InClass-&amp;gt;GetMinAlignment() ); Obj = (UObject *)GUObjectAllocator.AllocateUObject(TotalSize,Alignment,GIsInitialLoad); } else { // Replace an existing object without affecting the original&#39;s address or index. check(!Obj-&amp;gt;IsUnreachable()); check(!ObjectRestoreAfterInitProps); // otherwise recursive construction ObjectRestoreAfterInitProps = Obj-&amp;gt;GetRestoreForUObjectOverwrite(); // Remember linker, flags, index, and native class info. Linker = Obj-&amp;gt;GetLinker(); LinkerIndex = Obj-&amp;gt;GetLinkerIndex(); InternalSetFlags |= (Obj-&amp;gt;GetInternalFlags() &amp;amp; (EInternalObjectFlags::Native | EInternalObjectFlags::RootSet)); }}UObjectBase* FUObjectAllocator::AllocateUObject(int32 Size, int32 Alignment, bool bAllowPermanent){ if (bPlaceInPerm) { // Align current tail pointer and use it for object. uint8* AlignedPtr = Align( PermanentObjectPoolTail, Alignment ); // Update tail pointer. PermanentObjectPoolTail = AlignedPtr + Size; Result = (UObjectBase*)AlignedPtr; } else { // Allocate new memory of the appropriate size and alignment. Result = (UObjectBase*)FMemory::Malloc( AlignedSize ); }}void UObjectBase::AddObject(FName InName, EInternalObjectFlags InSetInternalFlags){ GUObjectArray.AllocateUObjectIndex(this); check(InName != NAME_None &amp;amp;&amp;amp; InternalIndex &amp;gt;= 0);}void FUObjectArray::AllocateUObjectIndex(UObjectBase* Object, bool bMergingThreads /*= false*/){ // Add to global table. FUObjectItem* ObjectItem = IndexToObject(Index); // At this point all not-compiled-in objects are not fully constructed yet and this is the earliest we can mark them as such ObjectItem-&amp;gt;SetFlags(EInternalObjectFlags::PendingConstruction); ObjectItem-&amp;gt;Object = Object; Object-&amp;gt;InternalIndex = Index;}Destroy Objectbool IncrementalDestroyGarbage(bool bUseTimeLimit, float TimeLimit){ while (GObjCurrentPurgeObjectIndex &amp;lt; GUnreachableObjects.Num()) { UObject* Object = static_cast&amp;lt;UObject*&amp;gt;(ObjectItem-&amp;gt;Object); // Send FinishDestroy message. Object-&amp;gt;ConditionalFinishDestroy(); } if (GObjFinishDestroyHasBeenRoutedToAllObjects &amp;amp;&amp;amp; !bTimeLimitReached) { // Perform actual object deletion. GAsyncPurge-&amp;gt;TickPurge(bUseTimeLimit, TimeLimit, GCStartTime); }}bool UObject::ConditionalFinishDestroy(){ check(IsValidLowLevel()); if( !HasAnyFlags(RF_FinishDestroyed) ) { SetFlags(RF_FinishDestroyed); FinishDestroy(); // Make sure this object can&#39;t be found through any delete listeners (annotation maps etc) after it&#39;s been FinishDestroyed GUObjectArray.RemoveObjectFromDeleteListeners(this); }}/** [GAME THREAD] Ticks the purge process on the game thread */void TickPurge(bool bUseTimeLimit, float TimeLimit, double StartTime){ bool bCanStartDestroyingGameThreadObjects = true; if (!Thread) { // If we&#39;re running single-threaded we need to tick the main loop here too LastUnreachableObjectsCount = GUnreachableObjects.Num(); bCanStartDestroyingGameThreadObjects = TickDestroyObjects&amp;lt;false&amp;gt;(bUseTimeLimit, TimeLimit, StartTime); } if (bCanStartDestroyingGameThreadObjects) { do { // Deal with objects that couldn&#39;t be destroyed on the worker thread. This will do nothing when running single-threaded bool bFinishedDestroyingObjectsOnGameThread = TickDestroyGameThreadObjects(bUseTimeLimit, TimeLimit, StartTime); if (!Thread &amp;amp;&amp;amp; bFinishedDestroyingObjectsOnGameThread) { // This only gets triggered here in single-threaded mode FinishedPurgeEvent-&amp;gt;Trigger(); } } while (!bUseTimeLimit &amp;amp;&amp;amp; !IsFinished()); }}/** [GAME THREAD] Destroys objects that are unreachable and couldn&#39;t be destroyed on the worker thread */bool TickDestroyGameThreadObjects(bool bUseTimeLimit, float TimeLimit, double StartTime){ while (NumObjectsDestroyedOnGameThread &amp;lt; LocalNumObjectsToDestroyOnGameThread &amp;amp;&amp;amp; ObjCurrentPurgeObjectIndexOnGameThread &amp;lt; GUnreachableObjects.Num()) { FUObjectItem* ObjectItem = GUnreachableObjects[ObjCurrentPurgeObjectIndexOnGameThread]; if (ObjectItem) { GUnreachableObjects[ObjCurrentPurgeObjectIndexOnGameThread] = nullptr; UObject* Object = (UObject*)ObjectItem-&amp;gt;Object; Object-&amp;gt;~UObject(); GUObjectAllocator.FreeUObject(Object); ++ProcessedObjectsCount; ++NumObjectsDestroyedOnGameThread; } ++ObjCurrentPurgeObjectIndexOnGameThread; }}/** * Final destructor, removes the object from the object array, and indirectly, from any annotations **/UObjectBase::~UObjectBase(){ // If not initialized, skip out. if( UObjectInitialized() &amp;amp;&amp;amp; ClassPrivate &amp;amp;&amp;amp; !GIsCriticalError ) { // Validate it. check(IsValidLowLevel()); check(GetFName() == NAME_None); GUObjectArray.FreeUObjectIndex(this); }}void FUObjectAllocator::FreeUObject(UObjectBase *Object) const{ if( ResidesInPermanentPool(Object) == false ) { FMemory::Free(Object); }}TWeakObjectPtrstruct FWeakObjectPtr{ int32 ObjectIndex; int32 ObjectSerialNumber;};// Allocate Serial numbervoid FWeakObjectPtr::operator=(const class UObject *Object){ if (Object // &amp;amp;&amp;amp; UObjectInitialized() we might need this at some point, but it is a speed hit we would prefer to avoid ) { ObjectIndex = GUObjectArray.ObjectToIndex((UObjectBase*)Object); ObjectSerialNumber = GUObjectArray.AllocateSerialNumber(ObjectIndex); checkSlow(SerialNumbersMatch()); } else { Reset(); }}int32 FUObjectArray::AllocateSerialNumber(int32 Index){ FUObjectItem* ObjectItem = IndexToObject(Index); checkSlow(ObjectItem); volatile int32 *SerialNumberPtr = &amp;amp;ObjectItem-&amp;gt;SerialNumber; int32 SerialNumber = *SerialNumberPtr; if (!SerialNumber) { SerialNumber = MasterSerialNumber.Increment(); UE_CLOG(SerialNumber &amp;lt;= START_SERIAL_NUMBER, LogUObjectArray, Fatal, TEXT(&quot;UObject serial numbers overflowed (trying to allocate serial number %d).&quot;), SerialNumber); int32 ValueWas = FPlatformAtomics::InterlockedCompareExchange((int32*)SerialNumberPtr, SerialNumber, 0); if (ValueWas != 0) { // someone else go it first, use their value SerialNumber = ValueWas; } } checkSlow(SerialNumber &amp;gt; START_SERIAL_NUMBER); return SerialNumber;}" }, { "title": "[ue4] Pak", "url": "/posts/pak/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Build", "date": "2022-02-13 21:09:00 +0900", "snippet": "                                                                                    " }, { "title": "[ue4] Build Graph", "url": "/posts/build-graph/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Build", "date": "2021-12-24 00:32:00 +0900", "snippet": "                                                                                    Build stepsCommand-line parametersD:\\Git\\UE4\\Engine\\Source\\Programs\\AutomationTool\\AutomationUtils\\ProjectParams.csbasic parameters-CrashReporter true if we should build crash reporter-clean wipe intermediate folders before building-signedPak true if it use encrypted pak files-signpak=keys sign the generated pak file with the specified key, i.e. -signpak=C:\\Encryption.keys. Also implies -signedpak.-RunAssetNativization convert blueprint assets to source code-pak generate a pak file-skippak use a pak file, but assume it is already built, implies pak-UTF8Output 로그, 콘솔 창 및 기타 출력은 UTF8 인코딩을 사용합니다.build parameters-build True if build step should be executed-SkipBuildClient Trun if then don&#39;t build the client exe-SkipBuildEditor True if then don&#39;t build the editor exe-noxge True if XGE should NOT be used for building-ForceDebugInfo Whether to force debug info to be generated.stage parameters-stage put this build in a stage directory-skipstage uses a stage directory, but assumes everything is already there, implies -stage-stagingdirectory=Path Directory to copy the builds to, i.e. -stagingdirectory=C:\\Stage-nodebuginfo do not copy debug files to the stage-nocleanstage skip cleaning the stage directory-StageCommandline=XYZ command line to put into the stage in UE4CommandLine.txt cook parameters-cook, -cookonthefly Determines if the build is going to use cooked data-skipcook use a cooked build, but we assume the cooked data is up to date and where it belongs, implies -cook-IgnoreCookErrors Ignores cook errors and continues with packaging etc-CookFlavor Multi/ATC/DXT/ETC1/ETC2/PVRTC/ASTC: Android cook formatting-CookPartialgc while cooking clean up packages as we are done with them rather then cleaning everything up when we run out of space-CookInEditor Did we cook in the editor instead of in UAT-CookOutputDir=C:\\cooked Output directory for cooked data. Default: Project/Saved/Cooked(UAT) &amp;amp; Project/Saved/EditorCooked(Editor)-AdditionalCookerOptions=xxx Additional cooker options to include on the cooker commandline-Compressed Compress packages during cook.-EncryptIniFiles encrypt ini files in the pak file-EncryptEverything Encrypt all files in the pak file. Secure, but will cause some slowdown to runtime IO performance, and high entropy to packaged data which will be bad for patching-EncryptPakIndex Encrypt the pak index, making it impossible to use unrealpak to manipulate the pak file without the encryption key-UnversionedCookedContent Do not include a version number in the cooked content-IterativeCooking(-Iterate) Uses the iterative cooking-CookAll Cook all the things in the content directory for this project-CookMapsOnly Only cook maps (and referenced content) instead of cooking everything only affects -cookall flag-MapsToCook=map1+map2+map3 List of maps to include when no other map list is specified on commandline-SkipCookingEditorContent Skips content under /Engine/Editor when cooking-NumCookersToSpawn=n number of additional cookers to spawn while cooking-FastCook Uses fast cook path if supported by targetrun parameters-실행: 빌드 완료 후 게임 실행-CookOnTheFly: 서버에서 쿠킹된 리소스 사용-CookOnTheFlyStreaming: 위와 동일하지만 리소스를 로컬로 캐시하지 않습니다.-FileServer: UnrealFileServer에서 쿠킹된 리소스 데이터 사용-DedicatedServer(-Server): 빌드 완료 후 ds 서버 실행-Client: TargetType.Client에 해당하는 구성을 사용하여 게임 실행-NoClient: 서버만 실행-LogWindow: 로그 창 생성-Map=xxx: 게임이 실행되는 레벨 지정-AdditionalServerMapParams=?param=value: 서버 맵의 추가 매개변수-NumClients=n: 클라이언트 수-AddCmdline=/-ServerCommandline=/-ClientCommandline=xx: 추가 프로세스 매개변수package parameters-package package the project for the target platform-skippackage Skips packaging the project for the target platform-distribution package for distribution the project-prereqs stage prerequisites along with the projectarchive parameters-archive put this build in an archive directory-archivedirectory=Path Directory to archive the builds to, i.e. -archivedirectory=C:\\Archive-createappbundle When archiving for Mac, set this to true to package it in a .app bundle instead of normal loose filesdeploy parameters-deploy deploy the project for the target platform-DeployFolder Location to deploy to on the target platform-project=Path Project path (required), i.e: -project=QAGame, -project=Samples\\BlackJack\\BlackJack.uproject, -project=D:\\Projects\\MyProject.uproject-destsample Destination Sample name-foreigndest Foreign Destination-targetplatform=PlatformName target platform for building, cooking and deployment (also -Platform)-servertargetplatform=PlatformName target platform for building, cooking and deployment of the dedicated server (also -ServerPlatform)-foreign Generate a foreign uproject from blankproject and use that-foreigncode Generate a foreign code uproject from platformergame and use that-skipcookonthefly in a cookonthefly build, used solely to pass information to the package step-unattended assumes no operator is present, always terminates without waiting for something.-iostore generate I/O store container file(s)-prepak attempt to avoid cooking and instead pull pak files from the network, implies pak and skipcook-signed the game should expect to use a signed pak file.-PakAlignForMemoryMapping The game will be set up for memory mapping bulk data.-skipiostore override the -iostore commandline option to not run it-manifests generate streaming install manifests when cooking data-createchunkinstall generate streaming install data from manifest when cooking data, requires -stage &amp;amp; -manifests-separatedebuginfo output debug info to a separate directory-MapFile generates a *.map file-run run the game after it is built (including server, if -server)-cookonthefly run the client with cooked data provided by cook on the fly server-Cookontheflystreaming run the client in streaming cook on the fly mode (don&#39;t cache files locally instead force reget from server each file load)-fileserver run the client with cooked data provided by UnrealFileServer-dedicatedserver build, cook and run both a client and a server (also -server)-client build, cook and run a client and a server, uses client target configuration-noclient do not run the client, just run the server-logwindow create a log window for the client-applocaldir location of prerequisites for applocal deployment-Prebuilt this is a prebuilt cooked and packaged build-AdditionalPackageOptions extra options to pass to the platform&#39;s packager-getfile download file from target after successful run-IgnoreLightMapErrors Whether Light Map errors should be treated as critical-ue4exe=ExecutableName Name of the UE4 Editor executable, i.e. -ue4exe=UE4Editor.exe-archivemetadata Archive extra metadata files in addition to the build (e.g. build.properties)-iterativecooking Uses the iterative cooking, command line: -iterativecooking or -iterate-CookMapsOnly Cook only maps this only affects usage of -cookall the flag-CookAll Cook all the things in the content directory for this project-SkipCookingEditorContent Skips content under /Engine/Editor when cooking-FastCook Uses fast cook path if supported by target-cmdline command line to put into the stage in UE4CommandLine.txt-bundlename string to use as the bundle name when deploying to mobile device-map map to run the game with-AdditionalServerMapParams Additional server map params, i.e ?param=value-device Devices to run the game on-serverdevice Device to run the server on-skipserver Skip starting the server-numclients=n Start extra clients, n should be 2 or more-addcmdline Additional command line arguments for the program-servercmdline Additional command line arguments for the program-clientcmdline Override command line arguments to pass to the client-nullrhi add -nullrhi to the client commandlines-fakeclient adds ?fake to the server URL-editortest rather than running a client, run the editor instead-RunAutomationTests when running -editortest or a client, run all automation tests, not compatible with -server-Crash=index when running -editortest or a client, adds commands like debug crash, debug rendercrash, etc based on index-deviceuser Linux username for unattended key genereation-devicepass Linux password-RunTimeoutSeconds timeout to wait after we lunch the game-SpecifiedArchitecture Determine a specific Minimum OS-UbtArgs extra options to pass to ubt-MapsToRebuildLightMaps List of maps that need light maps rebuilding-MapsToRebuildHLODMaps List of maps that need HLOD rebuilding-ForceMonolithic Toggle to combined the result into one executable-ForceDebugInfo Forces debug info even in development builds-ForceNonUnity Toggle to disable the unity build system-ForceUnity Toggle to force enable the unity build system-Licensee If set, this build is being compiled by a licensee-NoSign Skips signing of code/content files." }, { "title": "Blueprint", "url": "/posts/blueprint/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2021-12-23 05:27:00 +0900", "snippet": "                                                                                    Class DiagramUBlueprintActor에서 블루프린트 CPP 함수를 호출 과정1. 글루 기능 정의 UBT에 의해 리플렉션 코드 xyz.generated.h와 xyz.gen.cpp가 생성UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Replication)void SetReplicates(bool bInReplicates);void AActor::StaticRegisterNativesAActor(){ UClass* Class = AActor::StaticClass(); static const FNameNativePtrPair Funcs[] = { // ... { &quot;SetReplicates&quot;, &amp;amp;AActor::execSetReplicates }, // ... }; FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));}2. 런타임 상에 글루 기능 등록 모듈 시작 시 클래스를 등록하면서 IMPLEMENT_CLASS에 정의된 AutoInitialize 함수를 호출해준다.// Register a class at startup time.IMPLEMENT_CLASS(AActor, 2133058577);IMPLEMENT_CLASS는 글루 기능 등록" }, { "title": "[ue4] Root motion", "url": "/posts/root-motion/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Gameplay", "date": "2021-12-05 08:35:00 +0900", "snippet": "With Root MotionWithout Root motion" }, { "title": "Gameplay ability", "url": "/posts/gameplay-ability/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Gameplay", "date": "2021-12-05 08:35:00 +0900", "snippet": "Net Excution Policy Local Predicated 클라이언트에서 실행해서 서버로 전파 입력같은 클라이언트 예측에 의존 Local Only 클라이언트를 Ability 로컬에서 실행 서버에 대한 복제가 없음 Server Initiated 서버에서 시작해서 Ability를 클라이언트로 전파 Server Only 클라이언트에 복제되지 않음 Instancing Policy" }, { "title": "Gameplay ability task", "url": "/posts/gameplay-ability-task/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Gameplay", "date": "2021-12-05 08:35:00 +0900", "snippet": "AbilityTask_NetworkSyncPointvoid UAbilityTask_NetworkSyncPoint::Activate(){ if (IsPredictingClient()) { if (SyncType != EAbilityTaskNetSyncType::OnlyServerWait ) { // As long as we are waiting (!= OnlyServerWait), listen for the GenericSignalFromServer event ReplicatedEventToListenFor = EAbilityGenericReplicatedEvent::GenericSignalFromServer; } if (SyncType != EAbilityTaskNetSyncType::OnlyClientWait) { // As long as the server is waiting (!= OnlyClientWait), send the Server and RPC for this signal AbilitySystemComponent-&amp;gt;ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericSignalFromClient, GetAbilitySpecHandle(), GetActivationPredictionKey(), AbilitySystemComponent-&amp;gt;ScopedPredictionKey); } } else if (IsForRemoteClient()) { if (SyncType != EAbilityTaskNetSyncType::OnlyClientWait ) { // As long as we are waiting (!= OnlyClientWait), listen for the GenericSignalFromClient event ReplicatedEventToListenFor = EAbilityGenericReplicatedEvent::GenericSignalFromClient; } if (SyncType != EAbilityTaskNetSyncType::OnlyServerWait) { // As long as the client is waiting (!= OnlyServerWait), send the Server and RPC for this signal AbilitySystemComponent-&amp;gt;ClientSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericSignalFromServer, GetAbilitySpecHandle(), GetActivationPredictionKey()); } } if (ReplicatedEventToListenFor != EAbilityGenericReplicatedEvent::MAX) { CallOrAddReplicatedDelegate(ReplicatedEventToListenFor, FSimpleMulticastDelegate::FDelegate::CreateUObject(this, &amp;amp;UAbilityTask_NetworkSyncPoint::OnSignalCallback)); } else { // We aren&#39;t waiting for a replicated event, so the sync is complete. SyncFinished(); }}" }, { "title": "[ue4] Animation", "url": "/posts/animation/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Gameplay", "date": "2021-12-05 08:35:00 +0900", "snippet": "Animation class dialgramUSkeletonUAnimSequence" }, { "title": "[ue4] Casting", "url": "/posts/casting/", "categories": "Unreal Engine, Wiki", "tags": "ue4, Engine", "date": "2021-12-05 00:00:00 +0900", "snippet": "언리얼에서 사용되는 UObject Casting의 소스 코드                                                                                    UObject Casting// Dynamically cast an object type-safely.template &amp;lt;typename To, typename From&amp;gt;FORCEINLINE To* Cast(From* Src){ return TCastImpl&amp;lt;From, To&amp;gt;::DoCast(Src);}Cast Teamplatetemplate &amp;lt;typename From, typename To, ECastType CastType = TGetCastType&amp;lt;From, To&amp;gt;::Value&amp;gt;struct TCastImpl{ // This is the cast flags implementation FORCEINLINE static To* DoCast( UObject* Src ) { return Src &amp;amp;&amp;amp; Src-&amp;gt;GetClass()-&amp;gt;HasAnyCastFlag(TCastFlags&amp;lt;To&amp;gt;::Value) ? (To*)Src : nullptr; } FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src ) { return (To*)Src; }};template &amp;lt;typename From, typename To&amp;gt;struct TCastImpl&amp;lt;From, To, ECastType::UObjectToUObject&amp;gt;{ FORCEINLINE static To* DoCast( UObject* Src ) { return Src &amp;amp;&amp;amp; Src-&amp;gt;IsA&amp;lt;To&amp;gt;() ? (To*)Src : nullptr; } FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src ) { return (To*)Src; }};template &amp;lt;typename From, typename To&amp;gt;struct TCastImpl&amp;lt;From, To, ECastType::InterfaceToUObject&amp;gt;{ FORCEINLINE static To* DoCast( From* Src ) { To* Result = nullptr; if (Src) { UObject* Obj = Src-&amp;gt;_getUObject(); if (Obj-&amp;gt;IsA&amp;lt;To&amp;gt;()) { Result = (To*)Obj; } } return Result; } FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( From* Src ) { return Src ? (To*)Src-&amp;gt;_getUObject() : nullptr; }};template &amp;lt;typename From, typename To&amp;gt;struct TCastImpl&amp;lt;From, To, ECastType::UObjectToInterface&amp;gt;{ FORCEINLINE static To* DoCast( UObject* Src ) { return Src ? (To*)Src-&amp;gt;GetInterfaceAddress(To::UClassType::StaticClass()) : nullptr; } FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src ) { return Src ? (To*)Src-&amp;gt;GetInterfaceAddress(To::UClassType::StaticClass()) : nullptr; }};template &amp;lt;typename From, typename To&amp;gt;struct TCastImpl&amp;lt;From, To, ECastType::InterfaceToInterface&amp;gt;{ FORCEINLINE static To* DoCast( From* Src ) { return Src ? (To*)Src-&amp;gt;_getUObject()-&amp;gt;GetInterfaceAddress(To::UClassType::StaticClass()) : nullptr; } FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( From* Src ) { return Src ? (To*)Src-&amp;gt;_getUObject()-&amp;gt;GetInterfaceAddress(To::UClassType::StaticClass()) : nullptr; }};IsA/** Returns true if this object is of the specified type. */template &amp;lt;typename OtherClassType&amp;gt;FORCEINLINE bool IsA( OtherClassType SomeBase ) const{ // We have a cyclic dependency between UObjectBaseUtility and UClass, // so we use a template to allow inlining of something we haven&#39;t yet seen, because it delays compilation until the function is called. // &#39;static_assert&#39; that this thing is actually a UClass pointer or convertible to it. const UClass* SomeBaseClass = SomeBase; (void)SomeBaseClass; checkfSlow(SomeBaseClass, TEXT(&quot;IsA(NULL) cannot yield meaningful results&quot;)); const UClass* ThisClass = GetClass(); // Stop the compiler doing some unnecessary branching for nullptr checks UE_ASSUME(SomeBaseClass); UE_ASSUME(ThisClass); return IsChildOfWorkaround(ThisClass, SomeBaseClass);}/** Returns true if this object is of the template type. */template&amp;lt;class T&amp;gt;bool IsA() const{ return IsA(T::StaticClass());}template &amp;lt;typename ClassType&amp;gt;static FORCEINLINE bool IsChildOfWorkaround(const ClassType* ObjClass, const ClassType* TestCls){ return ObjClass-&amp;gt;IsChildOf(TestCls);}IsChildOfbool UStruct::IsChildOf( const UStruct* SomeBase ) const{ if (SomeBase == nullptr) { return false; } bool bOldResult = false; for ( const UStruct* TempStruct=this; TempStruct; TempStruct=TempStruct-&amp;gt;GetSuperStruct() ) { if ( TempStruct == SomeBase ) { bOldResult = true; break; }}#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY const bool bNewResult = IsChildOfUsingStructArray(*SomeBase);#endif#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK ensureMsgf(bOldResult == bNewResult, TEXT(&quot;New cast code failed&quot;));#endif return bOldResult;}Slate widget casting UObject가 아닌 Slate는 상속 관계를 알 수 없기때문에 안되기 때문에 위젯의 타입을 가져와서 캐스팅을 한다.TSharedPtr&amp;lt;SWidget&amp;gt; widget;if (widget-&amp;gt;GetType() == &quot;SObjectWidget&quot;){ SObjectWidget* objectWidget = static_cast&amp;lt;SObjectWidget*&amp;gt;(widget.Get());}" } ]
